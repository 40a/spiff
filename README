                                       _  __  __
                             ___ _ __ (_)/ _|/ _|
                            / __| '_ \| | |_| |_
                            \__ \ |_) | |  _|  _|
                            |___/ .__/|_|_| |_|
                                |_|

       A declarative templating system for BOSH deployment manifests.


= installation

  go install github.com/vito/spiff


= spiff merge template.yml [stub1.yml stub2.yml ...] > manifest.yml

  Merge stub files into one template, printing out the fully resolved manifest.

  See 'dynaml templating language' for details of the template file, or
  example.yml for a complicated example.


= spiff diff manifest.yml other-manifest.yml

  Show structural differences between two deployment manifests.

  Unlike 'bosh diff', this command has semantic knowledge of a deployment
  manifest, and is not just text-based. It also doesn't modify either file.

  It's tailed for checking differences between one deployment and the next.

  Typical flow:
    1. spiff merge template.yml [stubs...] > deployment.yml
      1a. bosh download manifest [deployment] current.yml
      1b. spiff diff deployment.yml current.yml
    2. bosh deployment deployment.yml
    3. bosh deploy


= dynaml templating language

Spiff uses a declarative, logic-free templating language called 'dynaml'
(dynamic yaml).

Every dynaml node is guaranteed to resolve to a YAML node. It is *not*
string interpolation. This keeps developers from having to think about how
a value will render in the resulting template.

A dynaml node appears in the .yml file as the value of a key, surrounded by
two parentheses.

The following is a complete list of dynaml expressions:

  (( foo )):
    look for the nearest 'foo' key (i.e. lexical scoping) and bring it in

  (( foo.bar.baz )):
    look for the nearest 'foo' key and get attributes on it

    if foo.bar is nil, return nil

  (( "foo" )):
    string literal

  (( "foo" bar ))
    concatenation (where bar is another arbitrary expr)

  (( auto )):
    context-sensitive; in a resource pool's instances: this means calculate
    based on the # of jobs declared in the pool

  (( merge )):
    bring the current path in from the template being diff'd against

    e.g.:

    foo:
      bar:
        baz: (( merge ))

    will bring in (( foo.bar.baz ))

    if the corresponding value is not defined, it will return nil

  (( a || b )):
    uses a or b if a is nil

  (( static_ips(N, "foo.static") )):
    function call (TODO)
